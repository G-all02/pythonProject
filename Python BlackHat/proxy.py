"""Есть несколько причин иметь в своем арсенале tcp-прокси. Его можно использовать для перенаправления трафика от
узла к узлу или для доступа к сетевому ПО. При выполнении тестирования на проникновение в корпоративных средах,
скорее всего, не будет возможности запустить Wireshark, также не сможем загрузить драйверы для анализа трафика
на локальном сетевом интерфейсе в windows, а сегментация сети не даст нам применить свои инструменты непосредсвенно
на атакуемом компьютере.
Прокси-сервер состоит из нескольких частей. Сейчас быстро пройдемся по четырем главным функциям, которые нужно
напсиать. Мы должны выводить взаимодействие между локальной и удаленной системами в консоль (hexdump). Нам нужно
принимать данные от локальной или удаленной системы с помощью входящего сокета (receive_from). Мы должны определять
направление трафика, которым обмениваются локальная и удаленная системы (proxy_handler). И наконец, должны подготовить
слушающий сокет и передать его нашей функции proxy_handler(server_loop)"""

import sys
import socket
import threading

"""Сначала мы импортируем несколько модулей. Затем определяем функцию hexdump, которая принимает ввод в виде байтов
и выводит его в консоль в шестнадцатиричном формате. То есть она показывает содержимое пакетов и как 
шестнадцатиричные значения, и как печатные символы ASCII. Это помогоает разобраться в неизвестных протоколах, 
обнаружить учетные данные пользователей, если взаимодействие не зашифорвано, и многое другое."""

HEX_FILTER = ''.join([(len(repr(chr(i))) == 3) and chr(i) or '.' for i in range(256)])  # 1.1

# 1.1 мы создаем строку hexfilter с печатными символами ASCII, если символ непечатный, вместо него выводится точка (.)

# В качестве примера того, что может содержать эта строка, возьмем символьное представление двух целых чисел, 30 и 65,
# в интерактивной оболочке python:

# >>> chr(65)
# 'A'
# >>> chr(30)
# '\x1e'
# >>> len(repr(chr(65)))
# 3
# >>> len(repr(chr(30)))
# 6

# Символьное представление 65 является печатным, а символьное представление 30 - нет. Как видно, представление печатного
# символа имеет длину 3. Воспользуемся этим фактом, чтобы получить итоговую строку HEXFILTER:
# предоставим символ, если это возможно, или точку (.), если нет.

# В списковом включении (list comprehension), с помощью которого создается строка, применяется метод укороченного
# вычисления булевых выражений. Это означает: если длина символа, соответсвующего целому числу в диапазоне 0...255,
# равна 3, мы берем сам символ (chr(i)), а если нет, то точку(.).


def hexdump(src, length=16, show=True):
    if isinstance(src, bytes):  # 1.2
        src = src.decode()

    results = list()
    for i in range(0, len(src), length):
        word = str(src[i:i+length])  # 1.3

        printable = word.translate(HEX_FILTER)  # 1.4
        hexa = ' '.join([f'{ord(c):02X}' for c in word])
        hexwidth = length*3
        results.append(f'{i:04x} {hexa:<{hexwidth}} {printable}')  # 1.5
    if show:
        for line in results:
            print(line)
    else:
        return results


# Списковое включение позволяет представить первые 256 целых чисел в виде печатных символов. Теперь можно написать
# функцию hexdump. Вначале нужно убедиться в том, что мы получили строку, для этого декодируем строку байтов, если она
# была передана 1.2. Дальше берем часть строки, которую нужно вывести, и присваиваем ее переменной word 1.3. Используем
# встроенную функцию translate, чтобы подставить вместо каждого символа в необработанной строке его строковое
# представление (printable) 1.4. Вместе с тем подставляем шестнадцатеричное представление целочисленного значения для
# каждого символа в исходной строке (hexa). В конце создаем новый массив result для хранения строк, он  будет содержать
# шестнадцатеричное значение индекса первого байта в слове (word), шестнадцатеричное значение слова и его печатное
# представление 1.5. Вывод выглядит так:

# >> hexdump('python rocks\n and proxies roll\n')
# 0000 70 79 74 68 6F 6E 20 72 6F 63 6B 73 0A 20 61 6E  python rocks. an
# 0010 64 20 70 72 6F 78 69 65 73 20 72 6F 6C 6C 0A     d proxies roll.

# Эта функция дает возможность наблюдать за трафиком, проходящим через прокси-сервер, в режиме реального времени.
